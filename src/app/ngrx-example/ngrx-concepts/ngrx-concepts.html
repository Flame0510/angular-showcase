<div class="intro-section">
  <h2>ğŸ¯ Cos'Ã¨ NgRx?</h2>
  <p>
    NgRx Ã¨ una libreria per la gestione dello stato in Angular basata sul
    pattern Redux. Fornisce un modo prevedibile di gestire lo stato
    dell'applicazione attraverso un flusso unidirezionale di dati.
  </p>

  <div class="architecture-diagram">
    <div class="flow-step">
      <div class="flow-box component">Component</div>
      <div class="flow-arrow">dispatch</div>
      <div class="flow-box action">Action</div>
    </div>
    <div class="flow-step">
      <div class="flow-arrow">â†’</div>
      <div class="flow-box reducer">Reducer</div>
      <div class="flow-arrow">â†’</div>
      <div class="flow-box store">Store</div>
    </div>
    <div class="flow-step">
      <div class="flow-arrow">select</div>
      <div class="flow-box selector">Selector</div>
      <div class="flow-arrow">subscribe</div>
    </div>
  </div>

  <div class="store-patterns">
    <h3>ğŸ“¦ Scegli il Pattern da Esplorare</h3>
    <p class="patterns-intro">
      Clicca su uno dei pattern per vedere una guida completa step-by-step
      con esempi dettagliati e spiegazioni per principianti.
    </p>
    <div class="patterns-comparison">
      <div
        class="pattern recommended clickable"
        [class.selected]="selectedPattern() === 'centralized'"
        (click)="selectPattern('centralized')">
        <h4>âœ… Store Centralizzato (Consigliato)</h4>
        <p>
          <strong>Pattern Redux:</strong> Store globale unico con stato combinato.
          Questo Ã¨ l'approccio consigliato per la maggior parte delle applicazioni
          in quanto fornisce una migliore visibilitÃ  dello stato, debug piÃ¹ semplice
          e un flusso di dati coerente.
        </p>
        <div class="pattern-pros">
          <strong>Vantaggi:</strong>
          <ul>
            <li>Unica fonte di veritÃ  (single source of truth)</li>
            <li>Debug piÃ¹ semplice con DevTools</li>
            <li>Migliore composizione dello stato</li>
            <li>Condivisione dati tra funzionalitÃ </li>
          </ul>
        </div>
        <div class="select-hint">
          ğŸ‘† Clicca per vedere la guida completa
        </div>
      </div>
      <div
        class="pattern alternative clickable"
        [class.selected]="selectedPattern() === 'feature'"
        (click)="selectPattern('feature')">
        <h4>âš¡ Feature Stores (Alternativa)</h4>
        <p>
          <strong>Pattern Modulare:</strong> Store separati per ogni funzionalitÃ .
          Utile per moduli lazy-loaded o funzionalitÃ  completamente indipendenti
          che non hanno mai bisogno di condividere lo stato.
        </p>
        <div class="pattern-pros">
          <strong>Casi d'uso:</strong>
          <ul>
            <li>FunzionalitÃ  lazy-loaded</li>
            <li>Moduli completamente isolati</li>
            <li>Architettura micro-frontend</li>
            <li>Sistemi basati su plugin</li>
          </ul>
        </div>
        <div class="select-hint">
          ğŸ‘† Clicca per vedere la guida completa
        </div>
      </div>
    </div>
  </div>
</div>

<div class="concepts-grid">
  @for (card of conceptCards; track card.title) {
    <app-concept-card
      [icon]="card.icon"
      [title]="card.title"
      [description]="card.description"
      [code]="card.code"
      [codeLanguage]="card.codeLanguage || 'typescript'"
      [keyPointsTitle]="card.keyPointsTitle"
      [keyPoints]="card.keyPoints">
    </app-concept-card>
  }
</div>

<!-- â•â•â• PATTERN GUIDE SECTION (Dynamic) â•â•â• -->
@if (selectedPattern()) {
  <div id="pattern-guide" class="pattern-guide-section">
    @if (selectedPattern() === 'centralized') {
      <!-- CENTRALIZED STORE GUIDE -->
      <div class="guide-header">
        <h2>ğŸ—ï¸ Guida Completa: Store Centralizzato (Redux Pattern)</h2>
        <p class="guide-intro">
          Lo <strong>Store Centralizzato</strong> Ã¨ il cuore dell'applicazione NgRx seguendo il pattern Redux.
          Tutti i dati dell'applicazione vivono in un unico albero di stato globale, accessibile da qualsiasi
          componente. Questa guida ti accompagnerÃ  passo-passo nella creazione di uno store centralizzato da zero.
        </p>
      </div>

      @for (step of centralizedSteps; track step.stepNumber) {
        <app-guide-step
          [stepNumber]="step.stepNumber"
          [title]="step.title"
          [explanation]="step.explanation"
          [codeExample]="step.codeExample"
          [explanationBox]="step.explanationBox">
        </app-guide-step>
      }

      <div class="guide-summary">
        <h3>ğŸ‰ Congratulazioni!</h3>
        <p>
          Hai appena creato uno <strong>Store Centralizzato</strong> completo con NgRx!
          Ora hai un'unica fonte di veritÃ  per tutti i dati dell'applicazione, con un flusso
          unidirezionale prevedibile e facilmente debuggabile.
        </p>
        <div class="next-steps">
          <h4>ğŸ“š Prossimi passi:</h4>
          <ul>
            <li>Esplora le <strong>Effects</strong> per gestire chiamate API e side effects</li>
            <li>Aggiungi piÃ¹ features seguendo lo stesso pattern</li>
            <li>Usa <strong>Redux DevTools</strong> per vedere lo stato in tempo reale</li>
            <li>Sperimenta con i demo Counter e Todo qui sotto!</li>
          </ul>
        </div>
      </div>
    }

    @if (selectedPattern() === 'feature') {
      <!-- FEATURE STORE GUIDE -->
      <div class="guide-header">
        <h2>âš¡ Guida Completa: Feature Stores (Pattern Modulare)</h2>
        <p class="guide-intro">
          I <strong>Feature Stores</strong> sono store indipendenti registrati dinamicamente per ogni feature.
          Ogni modulo gestisce il proprio stato isolato, ideale per applicazioni modulari, lazy-loading
          o architetture micro-frontend. Questa guida ti mostrerÃ  come crearli da zero.
        </p>
      </div>

      @for (step of featureSteps; track step.stepNumber) {
        <app-guide-step
          [stepNumber]="step.stepNumber"
          [title]="step.title"
          [explanation]="step.explanation"
          [codeExample]="step.codeExample"
          [explanationBox]="step.explanationBox">
        </app-guide-step>
      }

      <div class="guide-summary">
        <h3>ğŸ‰ Ottimo lavoro!</h3>
        <p>
          Hai creato un <strong>Feature Store</strong> modulare! Ora la tua app puÃ² caricare
          dinamicamente lo stato solo quando necessario, perfetto per grandi applicazioni
          con molti moduli indipendenti.
        </p>
        <div class="comparison-box">
          <h4>ğŸ“Š Store Centralizzato vs Feature Stores</h4>
          <div class="comparison-table">
            <div class="comparison-row header">
              <div>Aspetto</div>
              <div>Centralizzato</div>
              <div>Feature Stores</div>
            </div>
            <div class="comparison-row">
              <div>Setup iniziale</div>
              <div>Tutto definito in app.config</div>
              <div>Root vuoto, features si registrano</div>
            </div>
            <div class="comparison-row">
              <div>Bundle size</div>
              <div>Tutto caricato subito</div>
              <div>Solo ciÃ² che serve (lazy)</div>
            </div>
            <div class="comparison-row">
              <div>Condivisione stato</div>
              <div>Facile tra features</div>
              <div>PiÃ¹ complesso (serve mediazione)</div>
            </div>
            <div class="comparison-row">
              <div>DevTools</div>
              <div>Vista completa sempre</div>
              <div>Vista dinamica (features appaiono/scompaiono)</div>
            </div>
            <div class="comparison-row">
              <div>Ideale per</div>
              <div>App coese e medie dimensioni</div>
              <div>App molto grandi, micro-frontend, plugin</div>
            </div>
          </div>
        </div>
      </div>
    }
  </div>
}

<div class="setup-section">
  <h2>ğŸš€ Setup & Installazione</h2>
  <div class="setup-grid">
    <div class="setup-step">
      <h3>1. Installazione</h3>
      <app-code-block
        [code]="installCode"
        language="typescript"
      />
      <div class="note-box">
        <strong>âš ï¸ Nota per Angular 21+:</strong>
        <p>NgRx 20.x richiede Angular 20 come peer dependency. Per Angular 21, usa <code>--legacy-peer-deps</code> o crea un file <code>.npmrc</code> con <code>legacy-peer-deps=true</code></p>
      </div>
    </div>
    <div class="setup-step">
      <h3>2. Configurazione</h3>
      <app-code-block [code]="setupCode" language="typescript" />
    </div>
  </div>
</div>

<div class="best-practices">
  <h2>ğŸ’¡ Best Practices</h2>
  <div class="practices-grid">
    <div class="practice">
      <h4>ğŸ“ Struttura File</h4>
      <ul>
        <li>Organizza per funzionalitÃ </li>
        <li>Mantieni file piccoli</li>
        <li>Usa convenzioni di naming</li>
        <li>Separa le responsabilitÃ </li>
        <li>Setup store centralizzato</li>
      </ul>
    </div>
    <div class="practice">
      <h4>ğŸ”’ ImmutabilitÃ </h4>
      <ul>
        <li>Usa spread operator</li>
        <li>Non mutare lo stato</li>
        <li>Usa immer se necessario</li>
        <li>Congela lo stato in dev</li>
      </ul>
    </div>
    <div class="practice">
      <h4>ğŸ¯ Performance</h4>
      <ul>
        <li>Usa selectors memoizzati</li>
        <li>Normalizza lo stato</li>
        <li>OnPush change detection</li>
        <li>Evita logica nei reducers</li>
      </ul>
    </div>
    <div class="practice">
      <h4>ğŸ§ª Testing</h4>
      <ul>
        <li>Testa reducers isolati</li>
        <li>Mock degli effects</li>
        <li>Testa i selectors</li>
        <li>Test di integrazione</li>
      </ul>
    </div>
  </div>
</div>
